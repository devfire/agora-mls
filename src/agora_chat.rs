// This file is @generated by prost-build.
/// Main envelope for all messages transmitted over UDP multicast
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatPacket {
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    #[prost(string, tag = "3")]
    pub sender_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "chat_packet::MessageType", tags = "5, 6, 7, 8, 9, 10, 11, 12, 13")]
    pub message_type: ::core::option::Option<chat_packet::MessageType>,
}
/// Nested message and enum types in `ChatPacket`.
pub mod chat_packet {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MessageType {
        #[prost(message, tag = "5")]
        ApplicationMessage(super::ApplicationMessage),
        #[prost(message, tag = "6")]
        MlsMessage(super::MlsMessage),
        #[prost(message, tag = "7")]
        KeyPackage(super::KeyPackageMessage),
        #[prost(message, tag = "8")]
        GroupAnnouncement(super::GroupAnnouncement),
        #[prost(message, tag = "9")]
        MembershipUpdate(super::MembershipUpdate),
        #[prost(message, tag = "10")]
        Heartbeat(super::HeartbeatMessage),
        #[prost(message, tag = "11")]
        Error(super::ErrorMessage),
        #[prost(message, tag = "12")]
        KeyPackageRequest(super::KeyPackageRequest),
        #[prost(message, tag = "13")]
        GroupInfoRequest(super::GroupInfoRequest),
    }
}
/// Application-level chat messages (encrypted by MLS)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApplicationMessage {
    #[prost(string, tag = "1")]
    pub content: ::prost::alloc::string::String,
}
/// MLS protocol messages
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MlsMessage {
    #[prost(enumeration = "MlsMessageType", tag = "1")]
    pub message_type: i32,
    /// Serialized MLS message
    #[prost(bytes = "vec", tag = "2")]
    pub mls_content: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub epoch: u64,
}
/// Key package distribution
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyPackageMessage {
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// Serialized OpenMLS KeyPackage
    #[prost(bytes = "vec", tag = "2")]
    pub key_package: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "3")]
    pub expiry_time: u64,
    #[prost(string, repeated, tag = "4")]
    pub supported_ciphersuites: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Group announcements and discovery
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupAnnouncement {
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub creator_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub creation_time: u64,
    #[prost(uint32, tag = "5")]
    pub max_members: u32,
    #[prost(bool, tag = "6")]
    pub is_public: bool,
    #[prost(string, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Serialized MLS GroupInfo
    #[prost(bytes = "vec", tag = "8")]
    pub group_info: ::prost::alloc::vec::Vec<u8>,
}
/// Membership management
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MembershipUpdate {
    #[prost(enumeration = "MembershipAction", tag = "1")]
    pub action: i32,
    #[prost(string, repeated, tag = "2")]
    pub user_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, tag = "4")]
    pub epoch: u64,
}
/// Heartbeat for presence and connectivity
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatMessage {
    #[prost(enumeration = "UserStatus", tag = "1")]
    pub status: i32,
    #[prost(uint64, tag = "2")]
    pub last_seen: u64,
    #[prost(string, optional, tag = "3")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub active_groups: ::prost::alloc::vec::Vec<ActiveGroupInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActiveGroupInfo {
    #[prost(bytes = "vec", tag = "1")]
    pub group_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub last_activity: u64,
    #[prost(uint64, tag = "3")]
    pub current_epoch: u64,
}
/// Error handling
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorMessage {
    #[prost(enumeration = "ErrorType", tag = "1")]
    pub error_type: i32,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub related_message_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub error_code: u32,
}
/// Key package request for joining groups
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyPackageRequest {
    #[prost(string, tag = "1")]
    pub requesting_user_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub target_user_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub target_group_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, tag = "4")]
    pub requested_count: u32,
}
/// Group info request for discovery
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupInfoRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub group_id: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "2")]
    pub group_name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, tag = "4")]
    pub max_results: u32,
}
/// Enumerations
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MediaType {
    Unknown = 0,
    Image = 1,
    Video = 2,
    Audio = 3,
    Document = 4,
    Archive = 5,
}
impl MediaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MEDIA_TYPE_UNKNOWN",
            Self::Image => "MEDIA_TYPE_IMAGE",
            Self::Video => "MEDIA_TYPE_VIDEO",
            Self::Audio => "MEDIA_TYPE_AUDIO",
            Self::Document => "MEDIA_TYPE_DOCUMENT",
            Self::Archive => "MEDIA_TYPE_ARCHIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MEDIA_TYPE_UNKNOWN" => Some(Self::Unknown),
            "MEDIA_TYPE_IMAGE" => Some(Self::Image),
            "MEDIA_TYPE_VIDEO" => Some(Self::Video),
            "MEDIA_TYPE_AUDIO" => Some(Self::Audio),
            "MEDIA_TYPE_DOCUMENT" => Some(Self::Document),
            "MEDIA_TYPE_ARCHIVE" => Some(Self::Archive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SystemMessageType {
    SystemMessageUserJoined = 0,
    SystemMessageUserLeft = 1,
    SystemMessageUserKicked = 2,
    SystemMessageUserBanned = 3,
    SystemMessageGroupCreated = 4,
    SystemMessageGroupRenamed = 5,
    SystemMessageGroupDescriptionChanged = 6,
    SystemMessageAdminChanged = 7,
    SystemMessageEpochChanged = 8,
}
impl SystemMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SystemMessageUserJoined => "SYSTEM_MESSAGE_USER_JOINED",
            Self::SystemMessageUserLeft => "SYSTEM_MESSAGE_USER_LEFT",
            Self::SystemMessageUserKicked => "SYSTEM_MESSAGE_USER_KICKED",
            Self::SystemMessageUserBanned => "SYSTEM_MESSAGE_USER_BANNED",
            Self::SystemMessageGroupCreated => "SYSTEM_MESSAGE_GROUP_CREATED",
            Self::SystemMessageGroupRenamed => "SYSTEM_MESSAGE_GROUP_RENAMED",
            Self::SystemMessageGroupDescriptionChanged => {
                "SYSTEM_MESSAGE_GROUP_DESCRIPTION_CHANGED"
            }
            Self::SystemMessageAdminChanged => "SYSTEM_MESSAGE_ADMIN_CHANGED",
            Self::SystemMessageEpochChanged => "SYSTEM_MESSAGE_EPOCH_CHANGED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYSTEM_MESSAGE_USER_JOINED" => Some(Self::SystemMessageUserJoined),
            "SYSTEM_MESSAGE_USER_LEFT" => Some(Self::SystemMessageUserLeft),
            "SYSTEM_MESSAGE_USER_KICKED" => Some(Self::SystemMessageUserKicked),
            "SYSTEM_MESSAGE_USER_BANNED" => Some(Self::SystemMessageUserBanned),
            "SYSTEM_MESSAGE_GROUP_CREATED" => Some(Self::SystemMessageGroupCreated),
            "SYSTEM_MESSAGE_GROUP_RENAMED" => Some(Self::SystemMessageGroupRenamed),
            "SYSTEM_MESSAGE_GROUP_DESCRIPTION_CHANGED" => {
                Some(Self::SystemMessageGroupDescriptionChanged)
            }
            "SYSTEM_MESSAGE_ADMIN_CHANGED" => Some(Self::SystemMessageAdminChanged),
            "SYSTEM_MESSAGE_EPOCH_CHANGED" => Some(Self::SystemMessageEpochChanged),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MlsMessageType {
    MlsMessageProposal = 0,
    MlsMessageCommit = 1,
    MlsMessageWelcome = 2,
    MlsMessageGroupInfo = 3,
    MlsMessageKeyPackage = 4,
    MlsMessageApplication = 5,
}
impl MlsMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MlsMessageProposal => "MLS_MESSAGE_PROPOSAL",
            Self::MlsMessageCommit => "MLS_MESSAGE_COMMIT",
            Self::MlsMessageWelcome => "MLS_MESSAGE_WELCOME",
            Self::MlsMessageGroupInfo => "MLS_MESSAGE_GROUP_INFO",
            Self::MlsMessageKeyPackage => "MLS_MESSAGE_KEY_PACKAGE",
            Self::MlsMessageApplication => "MLS_MESSAGE_APPLICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MLS_MESSAGE_PROPOSAL" => Some(Self::MlsMessageProposal),
            "MLS_MESSAGE_COMMIT" => Some(Self::MlsMessageCommit),
            "MLS_MESSAGE_WELCOME" => Some(Self::MlsMessageWelcome),
            "MLS_MESSAGE_GROUP_INFO" => Some(Self::MlsMessageGroupInfo),
            "MLS_MESSAGE_KEY_PACKAGE" => Some(Self::MlsMessageKeyPackage),
            "MLS_MESSAGE_APPLICATION" => Some(Self::MlsMessageApplication),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MembershipAction {
    Add = 0,
    Remove = 1,
    Update = 2,
    AdminPromote = 3,
    AdminDemote = 4,
}
impl MembershipAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "MEMBERSHIP_ACTION_ADD",
            Self::Remove => "MEMBERSHIP_ACTION_REMOVE",
            Self::Update => "MEMBERSHIP_ACTION_UPDATE",
            Self::AdminPromote => "MEMBERSHIP_ACTION_ADMIN_PROMOTE",
            Self::AdminDemote => "MEMBERSHIP_ACTION_ADMIN_DEMOTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MEMBERSHIP_ACTION_ADD" => Some(Self::Add),
            "MEMBERSHIP_ACTION_REMOVE" => Some(Self::Remove),
            "MEMBERSHIP_ACTION_UPDATE" => Some(Self::Update),
            "MEMBERSHIP_ACTION_ADMIN_PROMOTE" => Some(Self::AdminPromote),
            "MEMBERSHIP_ACTION_ADMIN_DEMOTE" => Some(Self::AdminDemote),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserStatus {
    Offline = 0,
    Online = 1,
    Away = 2,
    Busy = 3,
    Invisible = 4,
}
impl UserStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Offline => "USER_STATUS_OFFLINE",
            Self::Online => "USER_STATUS_ONLINE",
            Self::Away => "USER_STATUS_AWAY",
            Self::Busy => "USER_STATUS_BUSY",
            Self::Invisible => "USER_STATUS_INVISIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_STATUS_OFFLINE" => Some(Self::Offline),
            "USER_STATUS_ONLINE" => Some(Self::Online),
            "USER_STATUS_AWAY" => Some(Self::Away),
            "USER_STATUS_BUSY" => Some(Self::Busy),
            "USER_STATUS_INVISIBLE" => Some(Self::Invisible),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorType {
    Unknown = 0,
    NetworkError = 1,
    ProtocolError = 2,
    AuthenticationError = 3,
    AuthorizationError = 4,
    GroupNotFound = 5,
    UserNotFound = 6,
    InvalidMessage = 7,
    CryptographicError = 8,
    EpochMismatch = 9,
    RateLimitExceeded = 10,
}
impl ErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_TYPE_UNKNOWN",
            Self::NetworkError => "ERROR_TYPE_NETWORK_ERROR",
            Self::ProtocolError => "ERROR_TYPE_PROTOCOL_ERROR",
            Self::AuthenticationError => "ERROR_TYPE_AUTHENTICATION_ERROR",
            Self::AuthorizationError => "ERROR_TYPE_AUTHORIZATION_ERROR",
            Self::GroupNotFound => "ERROR_TYPE_GROUP_NOT_FOUND",
            Self::UserNotFound => "ERROR_TYPE_USER_NOT_FOUND",
            Self::InvalidMessage => "ERROR_TYPE_INVALID_MESSAGE",
            Self::CryptographicError => "ERROR_TYPE_CRYPTOGRAPHIC_ERROR",
            Self::EpochMismatch => "ERROR_TYPE_EPOCH_MISMATCH",
            Self::RateLimitExceeded => "ERROR_TYPE_RATE_LIMIT_EXCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ERROR_TYPE_NETWORK_ERROR" => Some(Self::NetworkError),
            "ERROR_TYPE_PROTOCOL_ERROR" => Some(Self::ProtocolError),
            "ERROR_TYPE_AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
            "ERROR_TYPE_AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
            "ERROR_TYPE_GROUP_NOT_FOUND" => Some(Self::GroupNotFound),
            "ERROR_TYPE_USER_NOT_FOUND" => Some(Self::UserNotFound),
            "ERROR_TYPE_INVALID_MESSAGE" => Some(Self::InvalidMessage),
            "ERROR_TYPE_CRYPTOGRAPHIC_ERROR" => Some(Self::CryptographicError),
            "ERROR_TYPE_EPOCH_MISMATCH" => Some(Self::EpochMismatch),
            "ERROR_TYPE_RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
            _ => None,
        }
    }
}
