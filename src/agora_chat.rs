// This file is @generated by prost-build.
/// MlsMessageOut serves as a wrapper for messages produced by an OpenMLS group.
/// This is intended for publishing to a multicast topic where subscribers can
/// deserialize this wrapper and then process the inner MLS message payload.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AgoraPacket {
    /// Corresponds to the `version` field in the OpenMLS MlsMessageOut struct.
    #[prost(enumeration = "ProtocolVersion", tag = "1")]
    pub version: i32,
    /// The body of the message, corresponding to the MlsMessageBodyOut enum.
    /// The 'oneof' constraint ensures that a message can only be one of these types at a time,
    /// perfectly mapping the behavior of the Rust enum.
    #[prost(oneof = "agora_packet::Body", tags = "2, 3, 4, 6, 7")]
    pub body: ::core::option::Option<agora_packet::Body>,
}
/// Nested message and enum types in `AgoraPacket`.
pub mod agora_packet {
    /// The body of the message, corresponding to the MlsMessageBodyOut enum.
    /// The 'oneof' constraint ensures that a message can only be one of these types at a time,
    /// perfectly mapping the behavior of the Rust enum.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Body {
        #[prost(message, tag = "2")]
        PublicMessage(super::PublicMessage),
        #[prost(message, tag = "3")]
        PrivateMessage(super::PrivateMessage),
        #[prost(message, tag = "4")]
        GroupInfo(super::GroupInfo),
        #[prost(message, tag = "6")]
        UserAnnouncement(super::UserAnnouncement),
        #[prost(message, tag = "7")]
        EncryptedGroupInfo(super::EncryptedGroupInfo),
    }
}
/// A wrapper for an MLS PublicMessage.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PublicMessage {
    /// The raw bytes of the PublicMessage, serialized using tls_codec.
    #[prost(bytes = "vec", tag = "1")]
    pub tls_serialized_public_message: ::prost::alloc::vec::Vec<u8>,
}
/// A wrapper for an MLS PrivateMessage (Ciphertext).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivateMessage {
    /// The raw bytes of the PrivateMessage, serialized using tls_codec.
    #[prost(bytes = "vec", tag = "1")]
    pub tls_serialized_private_message: ::prost::alloc::vec::Vec<u8>,
}
/// A wrapper for an MLS Welcome message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Welcome {
    /// The raw bytes of the Welcome message, serialized using tls_codec.
    #[prost(bytes = "vec", tag = "1")]
    pub tls_serialized_welcome_message: ::prost::alloc::vec::Vec<u8>,
}
/// A wrapper for an MLS GroupInfo message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupInfo {
    /// The raw bytes of the GroupInfo message, serialized using tls_codec.
    #[prost(bytes = "vec", tag = "1")]
    pub tls_serialized_group_info: ::prost::alloc::vec::Vec<u8>,
}
/// A user announcement that includes both the KeyPackage and username.
/// This allows username-based discovery while keeping the KeyPackage intact.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserAnnouncement {
    /// The user's chosen display name/handle
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    /// The raw bytes of the KeyPackage, serialized using tls_codec.
    #[prost(bytes = "vec", tag = "2")]
    pub tls_serialized_key_package: ::prost::alloc::vec::Vec<u8>,
}
/// HPKE-encrypted GroupInfo for external commit joins.
/// This message contains the plaintext of the group id and a GroupInfo encrypted with the recipient's HPKE public key
/// from their KeyPackage, allowing secure transmission to a joining user who is
/// not yet a member of the group. The recipient can decrypt using their HPKE private
/// key and then use the GroupInfo to create an external commit.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptedGroupInfo {
    /// The KEM output from HPKE encryption.
    #[prost(bytes = "vec", tag = "1")]
    pub kem_output: ::prost::alloc::vec::Vec<u8>,
    /// The HPKE ciphertext containing the encrypted GroupInfo.
    #[prost(bytes = "vec", tag = "2")]
    pub ciphertext: ::prost::alloc::vec::Vec<u8>,
    /// The username of the sender who created this invitation.
    /// This allows recipients to know who invited them before decrypting.
    #[prost(string, tag = "3")]
    pub sender_username: ::prost::alloc::string::String,
    /// The sender's KeyPackage for return communication.
    /// This allows the recipient to encrypt messages back to the sender.
    #[prost(bytes = "vec", tag = "4")]
    pub sender_key_package: ::prost::alloc::vec::Vec<u8>,
}
/// Represents the MLS protocol version in use.
/// This should be kept in sync with the versions supported by your OpenMLS implementation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProtocolVersion {
    Unspecified = 0,
    /// Add other protocol versions as they become available/supported.
    Mls10 = 1,
}
impl ProtocolVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_VERSION_UNSPECIFIED",
            Self::Mls10 => "MLS_1_0",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "MLS_1_0" => Some(Self::Mls10),
            _ => None,
        }
    }
}
